"use strict";(self.webpackChunkarkane_docs=self.webpackChunkarkane_docs||[]).push([[882],{4508:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return p},default:function(){return h}});var n=a(7462),r=a(3366),i=(a(7294),a(3905)),o=["components"],s={sidebar_position:3},l="Create a feature",u={unversionedId:"arkane/create-a-feature",id:"arkane/create-a-feature",isDocsHomePage:!1,title:"Create a feature",description:"Creating your own features is also pretty easy. Features have many internal mechanisms that assist you in setting up the environment for your feature to operate in properly.",source:"@site/docs/arkane/create-a-feature.md",sourceDirName:"arkane",slug:"/arkane/create-a-feature",permalink:"/docs/arkane/create-a-feature",editUrl:"https://github.com/NobleDevelopment/Arkane-Docs/docs/arkane/create-a-feature.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Create a plugin",permalink:"/docs/arkane/create-a-plugin"}},p=[{value:"Object or class",id:"object-or-class",children:[]},{value:"Creating the pipeline",id:"creating-the-pipeline",children:[]},{value:"Feature properties",id:"feature-properties",children:[]}],c={toc:p};function h(e){var t=e.components,a=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"create-a-feature"},"Create a feature"),(0,i.kt)("p",null,"Creating your own features is also pretty easy. Features have many internal mechanisms that assist you in setting up the environment for your feature to operate in properly."),(0,i.kt)("h2",{id:"object-or-class"},"Object or class"),(0,i.kt)("p",null,"If your feature is a singleton, or should only ever have a single instance exist at a time, you should use an object. If your feature is unbound, and doesnt matter how many times it may exist on the stack, create a class. The method of creation is the same for both."),(0,i.kt)("p",null,"For this example, we will use an object."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'object MyFeature : Feature("MyAwesomeFeature", true) {\n}\n')),(0,i.kt)("p",null,"All we do here is create an object that extends Feature. Feature takes in a few parameters to instantiate. The first is the name of the feature, this is used for logging and property locations within the config system. The next parameter is whether or not the feature should be thread safe. Here, we will just go with true."),(0,i.kt)("h2",{id:"creating-the-pipeline"},"Creating the pipeline"),(0,i.kt)("p",null,"The point of the feature system is to allow reuse of features, and replace boiler plate code. This means that features can be ran in any environment and are blind to it. To combat this, we have a pipeline system that is called when a feature is installed. This is to allow the feature to setup the environment and allow for smooth operation. Here, you may setup listeners, commands, variables, settings. Anything you need. Pipelines are split into phases and will run in the order they are built in."),(0,i.kt)("p",null,"Lets create a pipeline for our feature! This feature will simply check if a player has permission to speak in chat."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'    override val pipeline: Pipeline = buildPipeline {\n        buildPhase("Setup Listeners"){\n            listen<AsyncChatEvent> { \n                if(player.hasPermission("chat.send").not()){\n                    isCancelled = true\n                }\n            }\n        }\n    }\n')),(0,i.kt)("p",null,"Here, we create a pipeline and build a phase called ",(0,i.kt)("em",{parentName:"p"},'"setup listeners"'),". In the phase, we listen to ",(0,i.kt)("strong",{parentName:"p"},"AsyncChatEvent")," and check if a player ",(0,i.kt)("strong",{parentName:"p"},"does not")," have the permission ",(0,i.kt)("em",{parentName:"p"},"chat.send"),". If they do not, we cancel the event."),(0,i.kt)("h2",{id:"feature-properties"},"Feature properties"),(0,i.kt)("p",null,"Features are capable of having properties that can be configured. This is all handled for you for free, you just have to tell arkane you want to use a property."),(0,i.kt)("p",null,"Lets setup a configurable message to send to the player if they are unable to chat."),(0,i.kt)("p",null,"First, we create and set the property."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'object MyFeature : Feature("MyAwesomeFeature", true) {\n    \n    private val notAbleToChatProp = setProperty("unable-to-chat", ConfigAdapters.String, "I\'m sorry, but you cannot chat here!")\n\n    override val pipeline: Pipeline = buildPipeline {}\n\n}\n')),(0,i.kt)("p",null,"Setting a property requires three things, a name/location (for accessing in a config), an adapter (to tell Arkane how to get it from the config), and a default value."),(0,i.kt)("p",null,"Now lets use the property to send a message!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'        buildPhase("Setup Listeners"){\n            listen<AsyncChatEvent> {\n                if(player.hasPermission("chat.send").not()){\n                    isCancelled = true\n                    player.sendMessage(Component.text(getProperty(notAbleToChatProp), NamedTextColor.RED))\n                }\n            }\n        }\n')),(0,i.kt)("p",null,"Here, we just call getProperty to retrieve the stored value!"))}h.isMDXComponent=!0}}]);